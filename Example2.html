<h1 id="live-data-ingestion-and-real-time-event-processing">Live Data Ingestion and Real-Time Event Processing</h1>
<p>Welcome to this example, where we&#39;ll explore how to set up a complete streaming workflow in kdb+ by ingesting live data feeds and processing real-time event streams. This tutorial will guide you through building a client-server architecture for ingesting data, appending it dynamically, and performing event-driven analytics on incoming data.</p>
<p>One of the key strengths of kdb+ is its ability to efficiently handle real-time data, making it an ideal choice for applications such as financial market data processing, IoT sensor monitoring, and high-speed telemetry analytics.</p>
<p>By the end of this example, you will understand how to:</p>
<ul>
<li>Establish a real-time data ingestion pipeline</li>
<li>Append incoming data dynamically to an in-memory table</li>
<li>Process real-time event streams and detect patterns</li>
<li>Perform calculations and update statistics dynamically</li>
<li>Implement monitoring and alerting based on data thresholds</li>
</ul>
<!-- Load Clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script>

<!-- Custom styling -->
<style>
  .code-container {
    position: relative;
    background-color: #e0e0e0;
    border: 1px solid #bbb;
  }
  .code-container code {
    font-size: 12px;
  }
  .copy-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    background: #007bff;
    color: white;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 12px;
    border-radius: 5px;
  }
  .copy-btn:hover {
    background: #0056b3;
  }
  .language-q {
     font-size: 20px;
     color: black;
  }
  
  /* Process Server - Blue */
  .process-s {
    background-color: #d0e6ff; /* Light blue */
    border-color: #7aa6d6;
  }
  .process-s .code-header {
    background-color: #b0d0ff;
    color: #003366;
  }
    
  /* Process Client - Green  */
  .process-c {
    background-color: #d4f4d7; /* Light green */
    border-color: #7ac67a;
  }
  .process-c .code-header {
    background-color: #a3e6a5;
    color: #004d00;
  }
    
  /* Process Alerts - Orange */
  .process-a {
    background-color: #ffe5b4; /* Light orange */
    border-color: #d6a67a;
  }
  .process-a .code-header {
    background-color: #ffcc80;
    color: #663300;
  }
</style>

<script>
  var clipboard = new ClipboardJS('.copy-btn');
  clipboard.on('success', function(e) {
    e.trigger.textContent = 'Copied!';
    setTimeout(() => (e.trigger.textContent = 'Copy Code'), 1500);
    e.clearSelection();
  });
</script>
<h2 id="1-prerequisites">1. Prerequisites</h2>
<ol>
<li>Select "Trust HTML: at the top of this page.</li>
<li>For setup instructions and prerequisites, please refer to the <a href="README.md">README</a>.</li>
<li>To run the code in this example you will need to launch two q terminals.<ul>
<li>If you are using the KX Academy sandbox, you can simply open a Terminal from the Launcher window and type q.</li>
<li>If you are running kdb+ locally, you can simply open a Terminal by and typing q.</li>
</ul>
</li>
</ol>
<img src="https://github.com/Connor-Gervin/kdb-recipes/blob/main/images/terminals.png?raw=true" alt="Render of the example setup" />

<h2 id="2-setup-the-server">2. Setup the Server</h2>
<p>A server in kdb+ is simply a process that listens for incoming data from other processes. This is useful in real-world scenarios where multiple sources (e.g., market data providers, sensors, trading engines) send real-time data to a centralized system.</p>
<p>First, let&#39;s setup a server process that listens for incoming data and stores it in an in-memory table. Run the following command in a terminal to launch a process specifying the port 1234 with <code>-q</code>.</p>
<div class="code-container process-s">
  <div class="code-header">Server </div>
  <button class="copy-btn" data-clipboard-target="#code-block-0">Copy Code</button>
  <pre><code class="language-q" id="code-block-0">q -p 1234</code></pre>
</div>
<p>By setting a port we have exposed this process so other clients can send data to it, the serve is now listening for incoming connections on port 1234.</p>
<p>Next, we can create an empty in-memory table named <code>t</code>, which will store our real-time data.</p>

<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-1">Copy Code</button>
  <pre><code class="language-q" id="code-block-1">t:([]time:`timestamp$();sym:`$();price:`float$();size:`long$())</code></pre>
</div>
<p>Here&#39;s a breakdown of what&#39;s happening:</p>
<ul>
<li>We define a new table with table notation <code>([] col1:&lt;values&gt;; col2:&lt;values&gt;: ....)</code> with empty values <code>()</code>:<ul>
<li><code>time</code> :Timestamp of the trade</li>
<li><code>sym</code> :Symbol</li>
<li><code>price</code> :Trade price</li>
<li><code>size</code> :Trade volume</li>
</ul>
</li>
</ul>
<p>Now the server and table are ready to receive data!</p>
<h2 id="3-setup-the-client">3. Setup the Client</h2>
<p>The client acts as a data source that continuously sends new trade events to the server. In real-world scenarios, this could be a market data feed, an IoT sensor, or a trading algorithm.</p>
<p>Open a new q session (client process) and establish a connection to the server using <code>hopen</code>:</p>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-2">Copy Code</button>
  <pre><code class="language-q" id="code-block-2">h:hopen 1234</code></pre>
</div>
<p>In the above:</p>
<ul>
<li><code>hopen 1234</code> creates a connection handle (h) to communicate with the server.</li>
<li>If the server is not running, this would return an error.</li>
</ul>
<p>The client is now connected to the server and ready to send data!</p>
<p>In kdb+, a client can send commands to a server using IPC (<code>hopen</code>). One way to add data to a table is by upserting new records into the table stored on the server.</p>
<p>Let&#39;s define a function <code>genData</code> to generate trade data.</p>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-3">Copy Code</button>
  <pre><code class="language-q" id="code-block-3">genData:{[n] ([] time:n#.z.P; sym:n?`A`B`C; price:10+n?10f; size:50*1+n?20)}</code></pre>
</div>
<p>In the above:</p>
<ul>
<li><code>{[]...}</code> is the syntax of function definition where we can pass any parameter values within <code>[]</code>, in our case this is <code>n</code> number of rows to create</li>
<li>We define a table with table notation <code>([] col1:&lt;values&gt;; col2:&lt;values&gt;: ....)</code> that matches the table schema on our server process<ul>
<li><code>time</code> is populated with timestamps using <code>#</code> to select</li>
<li><code>sym</code> is populated with random symbols selected from a list using <code>?</code></li>
<li><code>price</code> and trade <code>size</code> are randomnly generated</li>
</ul>
</li>
</ul>
<p>Let&#39;s test this works by passing 2 as the parameter <code>n</code> and we see that 2 rows of data are been generated.</p>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-4">Copy Code</button>
  <pre><code class="language-q" id="code-block-4">genData 2</code></pre>
</div>
</code></pre>
<pre><code>time                          sym price    size
-----------------------------------------------
2025.02.05D14:58:49.969964340 C   15.1598  650 
2025.02.05D14:58:49.969964340 B   14.06664 450 
</code></pre>
<p>Great, now we are ready to send this to our server process using the handle <code>h</code>.</p>

<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-5">Copy Code</button>
  <pre><code class="language-q" id="code-block-5">sendData:{[n] neg[h] (upsert;`t; genData[n])}</code></pre>
</div>
</code></pre>

<p>In the above:</p>
<ul>
<li><code>neg[h]</code> Sends the command to the server process, using <code>neg</code> to send asynchronously meaning we do not wait for the code to finish execution to proceed</li>
<li><code>(x;y;z)</code> Round brackets and semicolon here allow us to send the message as a list where:<ul>
<li><code>upsert</code> Appends new data to table</li>
<li><code>t</code> Is the table name on server process to append data to</li>
<li><code>genData[n]</code> Generates <code>n</code> rows of data</li>
</ul>
</li>
</ul>
<p>Let&#39;s run this for 5 rows of data and check the table on the server:</p>

</code></pre>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-6">Copy Code</button>
  <pre><code class="language-q" id="code-block-6">sendData 5</code></pre>
</div>
<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-7">Copy Code</button>
  <pre><code class="language-q" id="code-block-7">select from t</code></pre>
</div>
<pre><code>time                          sym price    size
-----------------------------------------------
2025.02.05D15:04:05.137048916 A   12.29662 600 
2025.02.05D15:04:05.137048916 B   16.91953 300 
2025.02.05D15:04:05.137048916 C   14.70788 350 
2025.02.05D15:04:05.137048916 B   16.34672 100 
2025.02.05D15:04:05.137048916 C   19.6724  300 
</code></pre>
<p>We can see 5 rows of data have been send from the client to the server process!</p>
<h2 id="4-simulate-a-continuous-data-feed">4. Simulate a Continuous Data Feed</h2>
<p>In real-world applications, data arrives continuously rather than in batches. Instead of manually sending data, we can automate the process using a timer that simulates an incoming data feed.</p>
<p>kdb+ provides a built-in timer function (<code>.z.ts</code>), which executes a given command at a set interval, we define this on the client process.</p>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-8">Copy Code</button>
  <pre><code class="language-q" id="code-block-8">.z.ts:{sendData 5+rand 5}
\t 1000
</code></pre>
</div>
<p>In the above:</p>
<ul>
<li><code>.z.ts</code> calls <code>sendData</code>, which sends 5-9 new trades to the server</li>
<li>Using <code>\t</code> we trigger it to run every 1000 milliseconds (1 second)</li>
</ul>
<p>We can run a <code>count</code> on the table <code>t</code> on our server process to see this in actiom , run it a few times to see the number increasing.</p>
<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-9">Copy Code</button>
  <pre><code class="language-q" id="code-block-9">count t</code></pre>
</div>
<p>You should now see a growing table of trades appearing every second.</p>
<p>At this point, the server continuously receives new trade data just like a real-time market data feed! </p>
<h2 id="5-prepare-to-receive-metrics">5. Prepare to Receive Metrics</h2>
<p>Next, let&#39;s define an empty <code>stats</code> table on the server process that will store calculated metrics such as the average price for each symbol.</p>

<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-10">Copy Code</button>
  <pre><code class="language-q" id="code-block-10">stats:([sym:`symbol$()] avgPrice:`float$(); time:`timestamp$())
</code></pre>
</div>
<p>This table will contain:</p>
<ul>
<li><code>sym</code>: The symbol of the trade</li>
<li><code>avgPrice</code>: The average price for each symbol, calculated as new trades come in</li>
<li><code>time</code>: The latest time of the trades</li>
</ul>
<p>We will be updating this table with aggregated metrics like avgPrice as trades are processed.</p>
<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-11">Copy Code</button>
  <pre><code class="language-q" id="code-block-11">select avgPrice:avg price,last time by sym from t</code></pre>
</div>
<p>Let&#39;s wrap that in a function using <code>{}</code> notation so we can trigger it on demand in the next step.</p>
<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-12">Copy Code</button>
  <pre><code class="language-q" id="code-block-12">calcStats:{`stats set select avgPrice:avg price,last time by sym from t}</code></pre>
</div>
<p>In the above:</p>
<ul>
<li>This function calculates the average price (avgPrice) grouped by sym (symbol)</li>
<li>The result is then stored back in the stats table using <code>set</code></li>
</ul>
<p>Now our server process is ready to add receive our calculated metrics.</p>
<h2 id="6-trigger-real-time-calculations">6. Trigger Real-Time Calculations</h2>
<p>To trigger the <code>calcStats</code> function every time a new trade record arrives, we can set up the <code>.z.ps</code> function. </p>
<h3 id="what-is-z-ps-">What is <code>.z.ps</code>?</h3>
<p>This function is one of the inbuilt event handlers in kdb+, and it allows you to set up periodic tasks that run automatically in the background when an event occurs - like new data arrives into the system. It is commonly used for logging, monitoring, and access control, but here, we leverage it for real-time metric updates.</p>
<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-13">Copy Code</button>
  <pre><code class="language-q" id="code-block-13">.z.ps:{ calcStats[]; value x}
</code></pre>
</div>
<p>In the above:</p>
<ul>
<li><code>.z.ps</code> executes the <code>calcStats</code> function whenever new data is received, ensuring the <code>stats</code> table is updated in real time.</li>
<li><code>value x</code> ensures that the event (in this case, a new trade) continues to propagate in the system</li>
</ul>
<p>This allows us to process incoming trades in real time and dynamically update the stats table.</p>
<p>To observe the real-time updates, periodically query the stats table and you will see the avgPrice values get updated.</p>
<div class="code-container process-s">
  <div class="code-header">Server</div>
  <button class="copy-btn" data-clipboard-target="#code-block-14">Copy Code</button>
  <pre><code class="language-q" id="code-block-14">select from stats
</code></pre>
</div>
<p>You should see the average price of each symbol (sym) being updated as new data arrives and the time updating. This is real-time event processing in action!</p>
<h2 id="7-implementing-real-time-alerts">7. Implementing Real-Time Alerts</h2>
<p>So far, we&#39;ve set up two processes:</p>
<ul>
<li>Server Process – Stores incoming trade data in table <code>t</code> and calculates real-time metrics in <code>stats</code>.</li>
<li>Client Process – Simulates market data by sending trade records to the server.
Now, we want to introduce a third process – a dedicated alerting process that listens for price movements and triggers alerts when certain thresholds are met.</li>
</ul>
<h3 id="why-do-we-need-a-separate-alert-process-">Why Do We Need a Separate Alert Process?</h3>
<p>While the server could handle alerting, separating this into its own process provides:</p>
<ul>
<li>Better Scalability – Keeps alerting logic independent of data ingestion.</li>
<li>Parallel Processing – Allows monitoring different conditions without overloading the main server.</li>
<li>Flexibility – New alerting rules or subscribers can be added easily.</li>
</ul>
<h3 id="step-1-set-up-the-alerting-process-and-logic">Step 1: Set Up the Alerting Process and Logic</h3>
<p>We start by launching a new q process for alerting on port 1235. In a new terminal, start q:</p>
<div class="code-container process-a">
  <div class="code-header">Alerts</div>
  <button class="copy-btn" data-clipboard-target="#code-block-15">Copy Code</button>
  <pre><code class="language-q" id="code-block-15">q -p 1235
</code></pre>
</div>
<p>Then, define the alerting process logic. The alerting process will receive trade data and monitor prices.</p>


<div class="code-container process-a">
  <div class="code-header">Alerts</div>
  <button class="copy-btn" data-clipboard-target="#code-block-16">Copy Code</button>
  <pre><code class="language-q" id="code-block-16">.z.ps:{price:(max x`price);if[price > 19; show "ALERT: Price ", string[price], " exceeded 19"]}
</code></pre>
</div>
<p>In the above:</p>
<ul>
<li><code>.z.ps</code> automatically triggers whenever the process receives data</li>
<li>It checks the highest price from incoming records</li>
<li>If the price exceeds 19, it prints an alert message using <code>show</code></li>
</ul>
<h3 id="step-2-modify-the-client-process-to-send-data-to-both-server-and-alerts-process">Step 2: Modify the Client Process to Send Data to Both Server and Alerts Process</h3>
<p>Our client process currently only sends trade data to the main server. We now modify it to also send data to the alerting process on port 1235.</p>
<p>In the client process, connect to both the server (port 1234) and the alerts process (port 1235):</p>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-17">Copy Code</button>
  <pre><code class="language-q" id="code-block-17">hServer: hopen 1234
hAlerts: hopen 1235
</code></pre>
</div>
<p>Adjust <code>sendData</code> so that every trade update is sent to both the server and the alerting process:</p>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-18">Copy Code</button>
  <pre><code class="language-q" id="code-block-18">sendData:{[n] data:genData[n]; neg[hServer] (upsert; `t; data);neg[hAlerts] (data)}
</code></pre>
</div>
<p>In the above:</p>
<ul>
<li>Generate n trade records using genData[n]</li>
<li>Stores the last message <code>data</code> for reference.</li>
<li>Sends <code>data</code> to both the server (hServer) and saves to table <code>t</code></li>
<li>Sends <code>data</code> to the alerting process (hAlerts)</li>
</ul>
<p>Now, every incoming trade will be processed by both systems.</p>
<p>As long as the timer is still running on the client process you should start to see ALERTS being published on the alerts process anytime a price exceeds 19.</p>
<pre><code><span class="hljs-string">"ALERT: Price 19.59409 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.4937 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.30361 exceeded 19"</span>
</code></pre><h3 id="step-3-logging-alerts">Step 3: Logging Alerts</h3>
<p>One more step we could take is to send these alerts to a logfile instead of printing them in the process. This is more realisttic to how a real life system would handle notifications.</p>
<p>Let&#39;s assume we want to create a new file to start writing a log to, we can create this file by opening a handle to it with <code>hopen</code>: </p>
<div class="code-container process-a">
  <div class="code-header">Alerts</div>
  <button class="copy-btn" data-clipboard-target="#code-block-19">Copy Code</button>
  <pre><code class="language-q" id="code-block-19">myFileHandle: hopen `:myLog.txt
</code></pre>
</div>
<p>Using <code>key</code> we can see this is in our current directory now as it returns the path so we know it exists.</p>
<div class="code-container process-a">
  <div class="code-header">Alerts</div>
  <button class="copy-btn" data-clipboard-target="#code-block-20">Copy Code</button>
  <pre><code class="language-q" id="code-block-20">key `:myLog.txt
</code></pre>
</div>
<p>Next, we can adjust <code>z.ps</code> in our alerts process to write to this file instead of printing.</p>
<div class="code-container process-a">
  <div class="code-header">Alerts</div>
  <button class="copy-btn" data-clipboard-target="#code-block-21">Copy Code</button>
  <pre><code class="language-q" id="code-block-21">.z.ps:{price:(max x`price);if[price > 19; neg[myFileHandle]("ALERT: Price ", string[price], " exceeded 19")]}
</code></pre>
</div>
<p>We can use the <code>read0</code> function.</p>
<div class="code-container process-a">
  <div class="code-header">Alerts</div>
  <button class="copy-btn" data-clipboard-target="#code-block-22">Copy Code</button>
  <pre><code class="language-q" id="code-block-22">read0 `:myLog.txt
</code></pre>
</div>
<pre><code><span class="hljs-string">"ALERT: Price 19.72533 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.74431 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.56339 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.8689 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.58704 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.68696 exceeded 19"</span>
<span class="hljs-string">"ALERT: Price 19.63594 exceeded 19"</span>
</code></pre><p>When we run this we can see our logfile now contains the alerts!</p>
<h2 id="8-cleanup">8. Cleanup</h2>
<p>Long-running timers or open connections can cause unintended issues, such as:</p>
<ul>
<li>Performance slowdowns (if <code>.z.ts</code> keeps running in the background)</li>
<li>Connection leaks (if clients don’t properly close hopen connections)</li>
</ul>
<p>It is good practice therefore to stop the timer on the client and close the connection when you are finished with this example:</p>
<div class="code-container process-c">
  <div class="code-header">Client</div>
  <button class="copy-btn" data-clipboard-target="#code-block-23">Copy Code</button>
  <pre><code class="language-q" id="code-block-23">\t 0
hclose hAlerts
hclose hServer
</code></pre>
</div>
<ul>
<li><code>\t 0</code> disables <code>.z.ts</code>, stopping the automatic data generation</li>
<li><code>hclose</code> closes the connection so the client can no longer communicate with the server process.</li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<p>At this stage, we have successfully set up:</p>
<ul>
<li>A main server process (port 1234) handling trade data and real-time metrics</li>
<li>A client process simulating real-time trade data</li>
<li>A separate alerting process (port 1235) monitoring price movements</li>
</ul>
<p>The example we’ve built here is designed to demonstrate just how powerful and elegant q/kdb+ is, even in its simplest form. In real life a professional kdb+ trading system would most likely make use of tick architecture, which:</p>
<ul>
<li>Logs all incoming data to disk for durability.</li>
<li>Sends updates to multiple subscribers (real-time databases, analytics engines)</li>
<li>Manages high-frequency streams efficiently</li>
</ul>
<p>To learn more about real-world kdb+ architecture, check out these resources:</p>
<ul>
<li>Free KX Course: <a href="#https://learninghub.kx.com/courses/kdb-architecture/">kdb+ Architecture</a> – A structured introduction to how kdb+ handles real-time and historical data.</li>
<li>GitHub: <a href="#https://github.com/KxSystems/kdb-tick">kdb-tick</a> – The official repository for tick.q, a production-grade framework for real-time data ingestion, storage, and analytics.</li>
</ul>
<p>This is how real-world trading systems ingest, process, and analyze billions of data points every day—and now you have the foundation to build your own! 🚀</p>
